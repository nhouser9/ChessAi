<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Board.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ChessAI</a> &gt; <a href="index.source.html" class="el_package">chessboard</a> &gt; <span class="el_source">Board.java</span></div><h1>Board.java</h1><pre class="source lang-java linenums">/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package chessboard;

import chessboard.moves.GenericMove;
import chessboard.moves.Move;
import chessboard.pieces.Bishop;
import chessboard.pieces.King;
import chessboard.pieces.Knight;
import chessboard.pieces.Pawn;
import chessboard.pieces.Piece;
import chessboard.pieces.Queen;
import chessboard.pieces.Rook;
import java.awt.Point;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

/**
 * Class representing the game board.
 *
 * @author Nick Houser
 */
public class Board {

    /**
     * The number of squares per one side of a chess board.
     */
    public static final int SQUARES_PER_SIDE = 8;

    /**
     * Method which checks whether a given co-ordinate is on the board.
     *
     * @param x the x co-ordinate to check
     * @param y the y co-ordinate to check
     * @return true if the passed position is within bounds, false otherwise
     */
    public static boolean inBounds(int x, int y) {
<span class="fc bfc" id="L43" title="All 2 branches covered.">        if (x &lt; 0) {</span>
<span class="fc" id="L44">            return false;</span>
        }

<span class="fc bfc" id="L47" title="All 2 branches covered.">        if (y &lt; 0) {</span>
<span class="fc" id="L48">            return false;</span>
        }

<span class="fc bfc" id="L51" title="All 2 branches covered.">        if (x &gt;= SQUARES_PER_SIDE) {</span>
<span class="fc" id="L52">            return false;</span>
        }

<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (y &gt;= SQUARES_PER_SIDE) {</span>
<span class="fc" id="L56">            return false;</span>
        }

<span class="fc" id="L59">        return true;</span>
    }

    /**
     * Method which returns the pieces necessary to set up the pieces for a
     * normal game.
     *
     * @return a list of Pieces that are on a regularly setup chessboard
     */
    public static List&lt;Piece&gt; initialState() {
<span class="fc" id="L69">        List&lt;Piece&gt; initialPieces = new LinkedList&lt;&gt;();</span>

<span class="fc" id="L71">        initialPieces.add(new Rook(Color.WHITE, 0, Color.WHITE.homeRow()));</span>
<span class="fc" id="L72">        initialPieces.add(new Knight(Color.WHITE, 1, Color.WHITE.homeRow()));</span>
<span class="fc" id="L73">        initialPieces.add(new Bishop(Color.WHITE, 2, Color.WHITE.homeRow()));</span>
<span class="fc" id="L74">        initialPieces.add(new Queen(Color.WHITE, 3, Color.WHITE.homeRow()));</span>
<span class="fc" id="L75">        initialPieces.add(new King(Color.WHITE, 4, Color.WHITE.homeRow()));</span>
<span class="fc" id="L76">        initialPieces.add(new Bishop(Color.WHITE, 5, Color.WHITE.homeRow()));</span>
<span class="fc" id="L77">        initialPieces.add(new Knight(Color.WHITE, 6, Color.WHITE.homeRow()));</span>
<span class="fc" id="L78">        initialPieces.add(new Rook(Color.WHITE, 7, Color.WHITE.homeRow()));</span>

<span class="fc bfc" id="L80" title="All 2 branches covered.">        for (int col = 0; col &lt; SQUARES_PER_SIDE; col++) {</span>
<span class="fc" id="L81">            initialPieces.add(new Pawn(Color.WHITE, col, Color.WHITE.pawnRow()));</span>
<span class="fc" id="L82">            initialPieces.add(new Pawn(Color.BLACK, col, Color.BLACK.pawnRow()));</span>
        }

<span class="fc" id="L85">        initialPieces.add(new Rook(Color.BLACK, 0, Color.BLACK.homeRow()));</span>
<span class="fc" id="L86">        initialPieces.add(new Knight(Color.BLACK, 1, Color.BLACK.homeRow()));</span>
<span class="fc" id="L87">        initialPieces.add(new Bishop(Color.BLACK, 2, Color.BLACK.homeRow()));</span>
<span class="fc" id="L88">        initialPieces.add(new Queen(Color.BLACK, 3, Color.BLACK.homeRow()));</span>
<span class="fc" id="L89">        initialPieces.add(new King(Color.BLACK, 4, Color.BLACK.homeRow()));</span>
<span class="fc" id="L90">        initialPieces.add(new Bishop(Color.BLACK, 5, Color.BLACK.homeRow()));</span>
<span class="fc" id="L91">        initialPieces.add(new Knight(Color.BLACK, 6, Color.BLACK.homeRow()));</span>
<span class="fc" id="L92">        initialPieces.add(new Rook(Color.BLACK, 7, Color.BLACK.homeRow()));</span>

<span class="fc" id="L94">        return initialPieces;</span>
    }

    //the color whose turn it is
    private Color activePlayer;

    //the move history
    private Stack&lt;Move&gt; moveHistory;
    //the array of pieces on the board

    private Piece[][] pieces;

    //a list of possible moves from this position
    private List&lt;Move&gt; possibleMoves;

    /**
     * Constructor which initializes the piece array to the initial chess board.
     * Defaults to the initial chess state if no list of pieces is passed in.
     *
     * @param initialPieces the initial pieces to add to the board
     * @param active the player whose turn it is
     */
<span class="fc" id="L116">    public Board(List&lt;Piece&gt; initialPieces, Color active) {</span>
<span class="fc" id="L117">        initializeFields(active);</span>
<span class="fc" id="L118">        setupPieces(initialPieces);</span>
<span class="fc" id="L119">    }</span>

    /**
     * Method which checks whether the active player can castle, which should be
     * true only if neither the king nor the left rook has moved, the king is
     * not in check, and the space to the side of the king is not under threat,
     * and none of the spaces required are occupied.
     *
     * @param direction the direction in which to castle; must be east or west
     * @param kingColor the color of the king trying to castle
     * @return true if the active player can castle left, false otherwise
     */
    public boolean canCastle(Direction direction, Color kingColor) {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (kingColor != activePlayer) {</span>
<span class="nc" id="L133">            return false;</span>
        }

<span class="fc bfc" id="L136" title="All 4 branches covered.">        if (direction != Direction.WEST &amp;&amp; direction != Direction.EAST) {</span>
<span class="fc" id="L137">            return false;</span>
        }

<span class="fc" id="L140">        int xIndex = 4;</span>
<span class="fc" id="L141">        Point kingPoint = new Point(xIndex, activePlayer.homeRow());</span>
<span class="fc" id="L142">        Piece kingSquareOccupant = occupant(kingPoint.x, kingPoint.y);</span>
<span class="fc bfc" id="L143" title="All 4 branches covered.">        if (kingSquareOccupant == null || kingSquareOccupant.hasMoved()) {</span>
<span class="fc" id="L144">            return false;</span>
        }

<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (moveSacksKing(new Move(this, kingSquareOccupant, kingPoint))) {</span>
<span class="fc" id="L148">            return false;</span>
        }

<span class="fc" id="L151">        kingPoint = new Point(kingPoint.x + direction.x(), kingPoint.y);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (moveSacksKing(new Move(this, kingSquareOccupant, kingPoint))) {</span>
<span class="fc" id="L153">            return false;</span>
        }

<span class="fc" id="L156">        xIndex = xIndex + direction.x();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (occupant(xIndex, activePlayer.homeRow()) != null) {</span>
<span class="fc" id="L158">            return false;</span>
        }

<span class="fc" id="L161">        xIndex = xIndex + direction.x();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (occupant(xIndex, activePlayer.homeRow()) != null) {</span>
<span class="fc" id="L163">            return false;</span>
        }

<span class="fc bfc" id="L166" title="All 2 branches covered.">        while (inBounds(xIndex + direction.x(), 0)) {</span>
<span class="fc" id="L167">            xIndex = xIndex + direction.x();</span>
        }
<span class="fc" id="L169">        Piece rookSquareOccupant = occupant(xIndex, activePlayer.homeRow());</span>
<span class="pc bpc" id="L170" title="1 of 4 branches missed.">        if (rookSquareOccupant == null || rookSquareOccupant.hasMoved()) {</span>
<span class="fc" id="L171">            return false;</span>
        }

<span class="fc" id="L174">        return true;</span>
    }

    /**
     * Method which returns a deep copy of this Board.
     *
     * @return a deep copy of this Board
     */
    public Board copyOf() {
<span class="fc" id="L183">        List&lt;Piece&gt; occupants = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (int col = 0; col &lt; Board.SQUARES_PER_SIDE; col++) {</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">            for (int row = 0; row &lt; Board.SQUARES_PER_SIDE; row++) {</span>
<span class="fc" id="L187">                Piece occupant = occupant(col, row);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">                if (occupant != null) {</span>
<span class="fc" id="L189">                    Piece copy = occupant.copyOf();</span>
<span class="fc" id="L190">                    occupants.add(copy);</span>
                }
            }
        }

<span class="fc" id="L195">        Board toReturn = new Board(occupants, activePlayer);</span>

<span class="fc" id="L197">        return toReturn;</span>
    }

    /**
     * Helper method which locates the king of a specific color.
     *
     * @param color the color of king to locate
     * @return the requested King
     */
    public King findKing(Color color) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        for (int col = 0; col &lt; Board.SQUARES_PER_SIDE; col++) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            for (int row = 0; row &lt; Board.SQUARES_PER_SIDE; row++) {</span>
<span class="fc" id="L209">                Piece occupant = occupant(col, row);</span>
<span class="fc bfc" id="L210" title="All 6 branches covered.">                if (occupant != null &amp;&amp; occupant instanceof King &amp;&amp; occupant.color == color) {</span>
<span class="fc" id="L211">                    return (King) occupant;</span>
                }
            }
        }
<span class="fc" id="L215">        return null;</span>
    }

    /**
     * Method which returns the player whose turn it is.
     *
     * @return the color whose turn it is
     */
    public Color getActivePlayer() {
<span class="fc" id="L224">        return activePlayer;</span>
    }

    /**
     * Method which changes control of the turn to the next player.
     */
    public void passTurn() {
<span class="nc" id="L231">        activePlayer = activePlayer.enemy();</span>
<span class="nc" id="L232">    }</span>

    /**
     * Method which checks the current board state for the king being
     * threatened. This is used to determine move validity.
     *
     * @param toCheck the King whose safety should be checked
     * @return true if the king is under threat, false otherwise
     */
    public boolean kingThreatened(King toCheck) {
        //knights
        Piece occupant;
<span class="fc" id="L244">        Point[] potentialKnightThreats = {</span>
<span class="fc" id="L245">            new Point(toCheck.position().x - 2, toCheck.position().y - 1),</span>
<span class="fc" id="L246">            new Point(toCheck.position().x - 1, toCheck.position().y - 2),</span>
<span class="fc" id="L247">            new Point(toCheck.position().x + 2, toCheck.position().y - 1),</span>
<span class="fc" id="L248">            new Point(toCheck.position().x + 1, toCheck.position().y - 2),</span>
<span class="fc" id="L249">            new Point(toCheck.position().x - 2, toCheck.position().y + 1),</span>
<span class="fc" id="L250">            new Point(toCheck.position().x - 1, toCheck.position().y + 2),</span>
<span class="fc" id="L251">            new Point(toCheck.position().x + 2, toCheck.position().y + 1),</span>
<span class="fc" id="L252">            new Point(toCheck.position().x + 1, toCheck.position().y + 2)</span>
        };
<span class="fc bfc" id="L254" title="All 2 branches covered.">        for (Point potentialKnightThreat : potentialKnightThreats) {</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (inBounds(potentialKnightThreat.x, potentialKnightThreat.y)) {</span>
<span class="fc" id="L256">                occupant = occupant(potentialKnightThreat.x, potentialKnightThreat.y);</span>
<span class="pc bpc" id="L257" title="1 of 6 branches missed.">                if (occupant != null &amp;&amp; occupant instanceof Knight &amp;&amp; occupant.color != toCheck.color) {</span>
<span class="nc" id="L258">                    return true;</span>
                }
            }
        }

        //pawns, bishops, rooks, queens, and kings
<span class="fc bfc" id="L264" title="All 2 branches covered.">        for (Direction dir : Direction.values()) {</span>
<span class="fc" id="L265">            int col = toCheck.position().x + dir.x();</span>
<span class="fc" id="L266">            int row = toCheck.position().y + dir.y();</span>
<span class="fc" id="L267">            occupant = null;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            while (inBounds(col, row)) {</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                if (occupant(col, row) != null) {</span>
<span class="fc" id="L270">                    occupant = occupant(col, row);</span>
<span class="fc" id="L271">                    break;</span>
                }
<span class="fc" id="L273">                col = col + dir.x();</span>
<span class="fc" id="L274">                row = row + dir.y();</span>
            }
<span class="fc bfc" id="L276" title="All 4 branches covered.">            if (occupant != null &amp;&amp; occupant.color != toCheck.color) {</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                if (occupant instanceof Queen) {</span>
<span class="fc" id="L278">                    return true;</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                } else if (occupant instanceof King) {</span>
<span class="nc" id="L280">                    int deltaX = Math.abs(occupant.position().x - toCheck.position().x);</span>
<span class="nc" id="L281">                    int deltaY = Math.abs(occupant.position().y - toCheck.position().y);</span>
<span class="nc bnc" id="L282" title="All 6 branches missed.">                    if (deltaX &lt;= 1 &amp; deltaY &lt;= 1) {</span>
<span class="nc" id="L283">                        return true;</span>
                    }
<span class="pc bfc" id="L285" title="All 2 branches covered.">                } else if (occupant instanceof Pawn) {</span>
<span class="fc" id="L286">                    int deltaX = Math.abs(occupant.position().x - toCheck.position().x);</span>
<span class="fc" id="L287">                    int yAfterCapture = occupant.position().y + occupant.color.forwardDirection().y();</span>
<span class="pc bpc" id="L288" title="3 of 4 branches missed.">                    if (yAfterCapture == toCheck.position().y &amp;&amp; deltaX == 1) {</span>
<span class="nc" id="L289">                        return true;</span>
                    }
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">                } else if (occupant instanceof Rook) {</span>
<span class="fc bfc" id="L292" title="All 8 branches covered.">                    if (dir == Direction.NORTH || dir == Direction.SOUTH || dir == Direction.EAST || dir == Direction.WEST) {</span>
<span class="fc" id="L293">                        return true;</span>
                    }
<span class="nc bnc" id="L295" title="All 2 branches missed.">                } else if (occupant instanceof Bishop) {</span>
<span class="nc bnc" id="L296" title="All 8 branches missed.">                    if (dir == Direction.NORTHWEST || dir == Direction.SOUTHWEST || dir == Direction.NORTHEAST || dir == Direction.SOUTHEAST) {</span>
<span class="nc" id="L297">                        return true;</span>
                    }
                }
            }
        }

<span class="fc" id="L303">        return false;</span>
    }

    /**
     * Method which attempts to execute a given move on this board. Returns
     * whether the move was a success. If so, the move will be made and added to
     * the move history.
     *
     * @param toExecute the move to make
     * @return true if the move succeeded, false otherwise
     */
    public boolean move(Move toExecute) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (validMoves().contains(toExecute)) {</span>
<span class="fc" id="L316">            updateBoard(toExecute);</span>
<span class="fc" id="L317">            activePlayer = activePlayer.enemy();</span>
<span class="fc" id="L318">            moveHistory.add(toExecute);</span>
<span class="fc" id="L319">            possibleMoves = null;</span>
<span class="fc" id="L320">            return true;</span>
        } else {
<span class="fc" id="L322">            return false;</span>
        }
    }

    /**
     * Method which checks whether a given move would allow the king to be
     * captured, which would make it illegal. Sets up the board as if the move
     * had been made then delegats the actual check to another method.
     *
     * @param toExecute the move to check
     * @return true if the move is illegal because it allows capture of the
     * king, false otherwise
     */
    public boolean moveSacksKing(Move toExecute) {
<span class="fc" id="L336">        updateBoard(toExecute);</span>

<span class="fc" id="L338">        King king = findKing(toExecute.piece.color);</span>
        boolean toReturn;
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (king == null) {</span>
<span class="fc" id="L341">            toReturn = false;</span>
        } else {
<span class="fc" id="L343">            toReturn = kingThreatened(king);</span>
        }

<span class="fc" id="L346">        revertBoard(toExecute);</span>

<span class="fc" id="L348">        return toReturn;</span>
    }

    /**
     * Method which returns the occupant of the given position.
     *
     * @param xPosition the x position to check
     * @param yPosition the y position to check
     * @return the Piece at the passed position
     */
    public Piece occupant(int xPosition, int yPosition) {
<span class="fc" id="L359">        return pieces[xPosition][yPosition];</span>
    }

    /**
     * Sets the occupant of the given position to the passed Piece.
     *
     * @param xPosition the x position to set
     * @param yPosition the y position to set
     * @param occupant the Piece to set in the position
     */
    public void setOccupant(int xPosition, int yPosition, Piece occupant) {
<span class="nc" id="L370">        pieces[xPosition][yPosition] = occupant;</span>
<span class="nc" id="L371">    }</span>

    /**
     * Method which returns a list of past moves made on the board.
     *
     * @return a list of past moves made on the board
     */
    public Move lastMove() {
<span class="fc bfc" id="L379" title="All 2 branches covered.">        if (moveHistory.isEmpty()) {</span>
<span class="fc" id="L380">            return null;</span>
        }
<span class="fc" id="L382">        return moveHistory.peek();</span>
    }

    public void removeLastMove() {
<span class="nc" id="L386">        moveHistory.pop();</span>
<span class="nc" id="L387">    }</span>

    //public void addToHistory(GenericMove move) {
    //moveHistory.add(move);
    //}
    /**
     * Method which attempts to revert a given move on this board. The move will
     * be undone and removed from the history.
     */
    public void revertMove() {
<span class="fc" id="L397">        Move lastMove = moveHistory.pop();</span>
<span class="fc" id="L398">        revertBoard(lastMove);</span>
<span class="fc" id="L399">        activePlayer = activePlayer.enemy();</span>
<span class="fc" id="L400">        possibleMoves = null;</span>
<span class="fc" id="L401">    }</span>

    /**
     * Method which returns a list of possible moves from this board state.
     *
     * @return a list of possible moves from this board state
     */
    public List&lt;Move&gt; validMoves() {
<span class="fc bfc" id="L409" title="All 2 branches covered.">        if (possibleMoves == null) {</span>
<span class="fc" id="L410">            possibleMoves = calculatePossibleMoves(activePlayer);</span>
        }
<span class="fc" id="L412">        return Collections.unmodifiableList(possibleMoves);</span>
    }

    /**
     * Method which resets the list of possible moves, which will force
     * recalculation.
     */
    public void resetValidMoves() {
<span class="nc" id="L420">        possibleMoves = null;</span>
<span class="nc" id="L421">    }</span>

    /**
     * Helper method which calculates the list of possible moves.
     *
     * @param player the player whose moves should be calculated
     * @return a list of possible moves in the current position
     */
    private List&lt;Move&gt; calculatePossibleMoves(Color player) {
<span class="fc" id="L430">        List&lt;Move&gt; toReturn = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">        for (int col = 0; col &lt; SQUARES_PER_SIDE; col++) {</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">            for (int row = 0; row &lt; SQUARES_PER_SIDE; row++) {</span>
<span class="fc" id="L433">                Piece occupant = occupant(col, row);</span>
<span class="fc bfc" id="L434" title="All 4 branches covered.">                if (occupant == null || occupant.color != player) {</span>
<span class="fc" id="L435">                    continue;</span>
                }
<span class="fc bfc" id="L437" title="All 2 branches covered.">                for (Point target : occupant.validMoves(this)) {</span>
<span class="fc" id="L438">                    Move potential = new Move(this, occupant, target);</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">                    if (moveSacksKing(potential)) {</span>
<span class="fc" id="L440">                        continue;</span>
                    }
<span class="fc" id="L442">                    toReturn.add(potential);</span>
<span class="fc" id="L443">                }</span>
            }
        }
<span class="fc" id="L446">        return toReturn;</span>
    }

    /**
     * Helper method which initializes fields to their default values.
     *
     * @param active the color whose turn it is
     */
    private void initializeFields(Color active) {
<span class="fc" id="L455">        pieces = new Piece[SQUARES_PER_SIDE][SQUARES_PER_SIDE];</span>
<span class="fc" id="L456">        activePlayer = active;</span>
<span class="fc" id="L457">        moveHistory = new Stack&lt;&gt;();</span>
<span class="fc" id="L458">        possibleMoves = null;</span>
<span class="fc" id="L459">    }</span>

    /**
     * Helper method which reverts the board and the Piece that was moved to
     * reflect the previous game state. Includes handling moves that affect more
     * than one piece, like en passant, queening, and castling.
     *
     * @param toExecute the move to make
     */
    private void revertBoard(Move toRevert) {
        //handle normal case
<span class="fc" id="L470">        Piece mover = toRevert.piece;</span>
<span class="fc" id="L471">        pieces[toRevert.from.x][toRevert.from.y] = mover;</span>
<span class="fc" id="L472">        mover.setPosition(toRevert.from);</span>
<span class="fc" id="L473">        mover.subMoveCount();</span>

        //handle en passant
<span class="fc bfc" id="L476" title="All 2 branches covered.">        if (toRevert.enPassant) {</span>
<span class="fc" id="L477">            pieces[toRevert.to.x][toRevert.to.y - mover.color.forwardDirection().y()] = toRevert.target;</span>
<span class="fc" id="L478">            pieces[toRevert.to.x][toRevert.to.y] = null;</span>
        } else {
<span class="fc" id="L480">            pieces[toRevert.to.x][toRevert.to.y] = toRevert.target;</span>
        }

        //handle castle
<span class="fc" id="L484">        int homeRow = mover.color.homeRow();</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (toRevert.castle) {</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (toRevert.to.x &gt; 4) {</span>
<span class="fc" id="L487">                pieces[7][homeRow] = pieces[5][homeRow];</span>
<span class="fc" id="L488">                pieces[5][homeRow] = null;</span>
<span class="fc" id="L489">                pieces[7][homeRow].setPosition(new Point(7, homeRow));</span>
            } else {
<span class="fc" id="L491">                pieces[0][homeRow] = pieces[3][homeRow];</span>
<span class="fc" id="L492">                pieces[3][homeRow] = null;</span>
<span class="fc" id="L493">                pieces[0][homeRow].setPosition(new Point(0, homeRow));</span>
            }
        }
<span class="fc" id="L496">    }</span>

    /**
     * Helper method which adds the inital pieces to the board.
     *
     * @param initialPieces the initial pieces to add
     */
    private void setupPieces(List&lt;Piece&gt; initialPieces) {
<span class="fc bfc" id="L504" title="All 2 branches covered.">        for (Piece piece : initialPieces) {</span>
<span class="fc" id="L505">            pieces[piece.position().x][piece.position().y] = piece;</span>
<span class="fc" id="L506">        }</span>
<span class="fc" id="L507">    }</span>

    /**
     * Helper method which updates the board and the Piece that was moved to
     * reflect the new game state. Includes handling moves that affect more than
     * one piece, like en passant, queening, and castling.
     *
     * @param toExecute the move to make
     */
    private void updateBoard(Move toExecute) {
        //handle normal case
<span class="fc" id="L518">        pieces[toExecute.from.x][toExecute.from.y] = null;</span>
<span class="fc" id="L519">        pieces[toExecute.to.x][toExecute.to.y] = toExecute.piece;</span>
<span class="fc" id="L520">        Piece mover = toExecute.piece;</span>
<span class="fc" id="L521">        mover.setPosition(toExecute.to);</span>
<span class="fc" id="L522">        mover.addMoveCount();</span>

        //handle en passant
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (toExecute.enPassant) {</span>
<span class="fc" id="L526">            pieces[toExecute.to.x][toExecute.to.y + 1] = null;</span>
<span class="fc" id="L527">            pieces[toExecute.to.x][toExecute.to.y - 1] = null;</span>
        }

        //handle castle
<span class="fc" id="L531">        int homeRow = mover.color.homeRow();</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (toExecute.castle) {</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">            if (toExecute.to.x &gt; 4) {</span>
<span class="fc" id="L534">                pieces[5][homeRow] = pieces[7][homeRow];</span>
<span class="fc" id="L535">                pieces[7][homeRow] = null;</span>
<span class="fc" id="L536">                pieces[5][homeRow].setPosition(new Point(5, homeRow));</span>
            } else {
<span class="fc" id="L538">                pieces[3][homeRow] = pieces[0][homeRow];</span>
<span class="fc" id="L539">                pieces[0][homeRow] = null;</span>
<span class="fc" id="L540">                pieces[3][homeRow].setPosition(new Point(3, homeRow));</span>
            }
        }

        //handle queening
<span class="fc bfc" id="L545" title="All 4 branches covered.">        if (mover instanceof Pawn &amp;&amp; mover.position().y == mover.color.queenRow()) {</span>
<span class="fc" id="L546">            pieces[mover.position().x][mover.position().y] = new Queen(mover.color, mover.position().x, mover.position().y);</span>
        }
<span class="fc" id="L548">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>